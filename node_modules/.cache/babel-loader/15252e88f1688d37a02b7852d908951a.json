{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : factory(global['apollo-cache-persist'] = {});\n})(this, function (exports) {\n  'use strict';\n\n  var Log = function () {\n    function Log(options) {\n      var _a = options.debug,\n          debug = _a === void 0 ? false : _a;\n      this.debug = debug;\n      this.lines = [];\n    }\n\n    Log.prototype.emit = function (level, message) {\n      if (level in console) {\n        var prefix = Log.prefix;\n        console[level].apply(console, [prefix].concat(message));\n      }\n    };\n\n    Log.prototype.tailLogs = function () {\n      var _this = this;\n\n      this.lines.forEach(function (_a) {\n        var level = _a[0],\n            message = _a[1];\n        return _this.emit(level, message);\n      });\n    };\n\n    Log.prototype.getLogs = function () {\n      return this.lines;\n    };\n\n    Log.prototype.write = function (level, message) {\n      var buffer = Log.buffer;\n      this.lines = this.lines.slice(1 - buffer).concat([[level, message]]);\n\n      if (this.debug || level !== 'log') {\n        this.emit(level, message);\n      }\n    };\n\n    Log.prototype.info = function () {\n      var message = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        message[_i] = arguments[_i];\n      }\n\n      this.write('log', message);\n    };\n\n    Log.prototype.warn = function () {\n      var message = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        message[_i] = arguments[_i];\n      }\n\n      this.write('warn', message);\n    };\n\n    Log.prototype.error = function () {\n      var message = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        message[_i] = arguments[_i];\n      }\n\n      this.write('error', message);\n    };\n\n    Log.buffer = 30;\n    Log.prefix = '[apollo-cache-persist]';\n    return Log;\n  }();\n\n  var Cache = function () {\n    function Cache(options) {\n      var cache = options.cache,\n          _a = options.serialize,\n          serialize = _a === void 0 ? true : _a;\n      this.cache = cache;\n      this.serialize = serialize;\n    }\n\n    Cache.prototype.extract = function () {\n      var data = this.cache.extract();\n\n      if (this.serialize) {\n        data = JSON.stringify(data);\n      }\n\n      return data;\n    };\n\n    Cache.prototype.restore = function (data) {\n      if (this.serialize && typeof data === 'string') {\n        data = JSON.parse(data);\n      }\n\n      if (data != null) {\n        this.cache.restore(data);\n      }\n    };\n\n    return Cache;\n  }();\n\n  var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n\n      function rejected(value) {\n        try {\n          step(generator[\"throw\"](value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n\n      function step(result) {\n        result.done ? resolve(result.value) : new P(function (resolve) {\n          resolve(result.value);\n        }).then(fulfilled, rejected);\n      }\n\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n  };\n\n  var __generator = undefined && undefined.__generator || function (thisArg, body) {\n    var _ = {\n      label: 0,\n      sent: function sent() {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n        f,\n        y,\n        t,\n        g;\n    return g = {\n      next: verb(0),\n      \"throw\": verb(1),\n      \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n      return this;\n    }), g;\n\n    function verb(n) {\n      return function (v) {\n        return step([n, v]);\n      };\n    }\n\n    function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n\n      while (_) {\n        try {\n          if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [0, t.value];\n\n          switch (op[0]) {\n            case 0:\n            case 1:\n              t = op;\n              break;\n\n            case 4:\n              _.label++;\n              return {\n                value: op[1],\n                done: false\n              };\n\n            case 5:\n              _.label++;\n              y = op[1];\n              op = [0];\n              continue;\n\n            case 7:\n              op = _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n\n            default:\n              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                _ = 0;\n                continue;\n              }\n\n              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                _.label = op[1];\n                break;\n              }\n\n              if (op[0] === 6 && _.label < t[1]) {\n                _.label = t[1];\n                t = op;\n                break;\n              }\n\n              if (t && _.label < t[2]) {\n                _.label = t[2];\n\n                _.ops.push(op);\n\n                break;\n              }\n\n              if (t[2]) _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n          }\n\n          op = body.call(thisArg, _);\n        } catch (e) {\n          op = [6, e];\n          y = 0;\n        } finally {\n          f = t = 0;\n        }\n      }\n\n      if (op[0] & 5) throw op[1];\n      return {\n        value: op[0] ? op[1] : void 0,\n        done: true\n      };\n    }\n  };\n\n  var Storage = function () {\n    function Storage(options) {\n      var storage = options.storage,\n          _a = options.key,\n          key = _a === void 0 ? 'apollo-cache-persist' : _a;\n      this.storage = storage;\n      this.key = key;\n    }\n\n    Storage.prototype.read = function () {\n      return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          return [2, this.storage.getItem(this.key)];\n        });\n      });\n    };\n\n    Storage.prototype.write = function (data) {\n      return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4, this.storage.setItem(this.key, data)];\n\n            case 1:\n              _a.sent();\n\n              return [2];\n          }\n        });\n      });\n    };\n\n    Storage.prototype.purge = function () {\n      return __awaiter(this, void 0, void 0, function () {\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4, this.storage.removeItem(this.key)];\n\n            case 1:\n              _a.sent();\n\n              return [2];\n          }\n        });\n      });\n    };\n\n    Storage.prototype.getSize = function () {\n      return __awaiter(this, void 0, void 0, function () {\n        var data;\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              return [4, this.storage.getItem(this.key)];\n\n            case 1:\n              data = _a.sent();\n\n              if (data == null) {\n                return [2, 0];\n              } else {\n                return [2, typeof data === 'string' ? data.length : null];\n              }\n\n              return [2];\n          }\n        });\n      });\n    };\n\n    return Storage;\n  }();\n\n  var __awaiter$1 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) {\n        try {\n          step(generator.next(value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n\n      function rejected(value) {\n        try {\n          step(generator[\"throw\"](value));\n        } catch (e) {\n          reject(e);\n        }\n      }\n\n      function step(result) {\n        result.done ? resolve(result.value) : new P(function (resolve) {\n          resolve(result.value);\n        }).then(fulfilled, rejected);\n      }\n\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n  };\n\n  var __generator$1 = undefined && undefined.__generator || function (thisArg, body) {\n    var _ = {\n      label: 0,\n      sent: function sent() {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n        f,\n        y,\n        t,\n        g;\n    return g = {\n      next: verb(0),\n      \"throw\": verb(1),\n      \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n      return this;\n    }), g;\n\n    function verb(n) {\n      return function (v) {\n        return step([n, v]);\n      };\n    }\n\n    function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n\n      while (_) {\n        try {\n          if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [0, t.value];\n\n          switch (op[0]) {\n            case 0:\n            case 1:\n              t = op;\n              break;\n\n            case 4:\n              _.label++;\n              return {\n                value: op[1],\n                done: false\n              };\n\n            case 5:\n              _.label++;\n              y = op[1];\n              op = [0];\n              continue;\n\n            case 7:\n              op = _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n\n            default:\n              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                _ = 0;\n                continue;\n              }\n\n              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                _.label = op[1];\n                break;\n              }\n\n              if (op[0] === 6 && _.label < t[1]) {\n                _.label = t[1];\n                t = op;\n                break;\n              }\n\n              if (t && _.label < t[2]) {\n                _.label = t[2];\n\n                _.ops.push(op);\n\n                break;\n              }\n\n              if (t[2]) _.ops.pop();\n\n              _.trys.pop();\n\n              continue;\n          }\n\n          op = body.call(thisArg, _);\n        } catch (e) {\n          op = [6, e];\n          y = 0;\n        } finally {\n          f = t = 0;\n        }\n      }\n\n      if (op[0] & 5) throw op[1];\n      return {\n        value: op[0] ? op[1] : void 0,\n        done: true\n      };\n    }\n  };\n\n  var Persistor = function () {\n    function Persistor(_a, options) {\n      var log = _a.log,\n          cache = _a.cache,\n          storage = _a.storage;\n      var _b = options.maxSize,\n          maxSize = _b === void 0 ? 1024 * 1024 : _b;\n      this.log = log;\n      this.cache = cache;\n      this.storage = storage;\n      this.paused = false;\n\n      if (maxSize) {\n        this.maxSize = maxSize;\n      }\n    }\n\n    Persistor.prototype.persist = function () {\n      return __awaiter$1(this, void 0, void 0, function () {\n        var data, error_1;\n        return __generator$1(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 4,, 5]);\n\n              data = this.cache.extract();\n              if (!(this.maxSize != null && typeof data === 'string' && data.length > this.maxSize && !this.paused)) return [3, 2];\n              return [4, this.purge()];\n\n            case 1:\n              _a.sent();\n\n              this.paused = true;\n              return [2];\n\n            case 2:\n              if (this.paused) {\n                this.paused = false;\n              }\n\n              return [4, this.storage.write(data)];\n\n            case 3:\n              _a.sent();\n\n              this.log.info(typeof data === 'string' ? \"Persisted cache of size \" + data.length : 'Persisted cache');\n              return [3, 5];\n\n            case 4:\n              error_1 = _a.sent();\n              this.log.error('Error persisting cache', error_1);\n              throw error_1;\n\n            case 5:\n              return [2];\n          }\n        });\n      });\n    };\n\n    Persistor.prototype.restore = function () {\n      return __awaiter$1(this, void 0, void 0, function () {\n        var data, error_2;\n        return __generator$1(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 5,, 6]);\n\n              return [4, this.storage.read()];\n\n            case 1:\n              data = _a.sent();\n              if (!(data != null)) return [3, 3];\n              return [4, this.cache.restore(data)];\n\n            case 2:\n              _a.sent();\n\n              this.log.info(typeof data === 'string' ? \"Restored cache of size \" + data.length : 'Restored cache');\n              return [3, 4];\n\n            case 3:\n              this.log.info('No stored cache to restore');\n              _a.label = 4;\n\n            case 4:\n              return [3, 6];\n\n            case 5:\n              error_2 = _a.sent();\n              this.log.error('Error restoring cache', error_2);\n              throw error_2;\n\n            case 6:\n              return [2];\n          }\n        });\n      });\n    };\n\n    Persistor.prototype.purge = function () {\n      return __awaiter$1(this, void 0, void 0, function () {\n        var error_3;\n        return __generator$1(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              _a.trys.push([0, 2,, 3]);\n\n              return [4, this.storage.purge()];\n\n            case 1:\n              _a.sent();\n\n              this.log.info('Purged cache storage');\n              return [3, 3];\n\n            case 2:\n              error_3 = _a.sent();\n              this.log.error('Error purging cache storage', error_3);\n              throw error_3;\n\n            case 3:\n              return [2];\n          }\n        });\n      });\n    };\n\n    return Persistor;\n  }();\n\n  var onCacheWrite = function onCacheWrite(_a) {\n    var cache = _a.cache;\n    return function (persist) {\n      var write = cache.write;\n\n      cache.write = function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        write.apply(cache, args);\n        persist();\n      };\n\n      return function () {\n        cache.write = write;\n      };\n    };\n  };\n\n  var onAppBackground = function onAppBackground(_a) {\n    var log = _a.log,\n        cache = _a.cache;\n    return function (persist) {\n      log.warn('Trigger option `background` not available on web; using `write` trigger');\n      return onCacheWrite({\n        cache: cache\n      })(persist);\n    };\n  };\n\n  var Trigger = function () {\n    function Trigger(_a, options) {\n      var log = _a.log,\n          persistor = _a.persistor;\n\n      var _this = this;\n\n      this.fire = function () {\n        if (!_this.debounce) {\n          _this.persist();\n\n          return;\n        }\n\n        if (_this.timeout != null) {\n          clearTimeout(_this.timeout);\n        }\n\n        _this.timeout = setTimeout(_this.persist, _this.debounce);\n      };\n\n      this.persist = function () {\n        if (_this.paused) {\n          return;\n        }\n\n        _this.persistor.persist();\n      };\n\n      var defaultDebounce = Trigger.defaultDebounce;\n      var cache = options.cache,\n          debounce = options.debounce,\n          _b = options.trigger,\n          trigger = _b === void 0 ? 'write' : _b;\n\n      if (!trigger) {\n        return;\n      }\n\n      this.debounce = debounce != null ? debounce : defaultDebounce;\n      this.persistor = persistor;\n      this.paused = false;\n\n      switch (trigger) {\n        case 'write':\n          this.uninstall = onCacheWrite({\n            cache: cache\n          })(this.fire);\n          break;\n\n        case 'background':\n          if (debounce) {\n            log.warn('Debounce is not recommended with `background` trigger');\n          }\n\n          this.debounce = debounce;\n          this.uninstall = onAppBackground({\n            cache: cache,\n            log: log\n          })(this.fire);\n          break;\n\n        default:\n          if (typeof trigger === 'function') {\n            this.uninstall = trigger(this.fire);\n          } else {\n            throw Error(\"Unrecognized trigger option: \" + trigger);\n          }\n\n      }\n    }\n\n    Trigger.prototype.pause = function () {\n      this.paused = true;\n    };\n\n    Trigger.prototype.resume = function () {\n      this.paused = false;\n    };\n\n    Trigger.prototype.remove = function () {\n      if (this.uninstall) {\n        this.uninstall();\n        this.uninstall = null;\n        this.paused = true;\n      }\n    };\n\n    Trigger.defaultDebounce = 1000;\n    return Trigger;\n  }();\n\n  var CachePersistor = function () {\n    function CachePersistor(options) {\n      if (!options.cache) {\n        throw new Error('In order to persist your Apollo Cache, you need to pass in a cache. ' + 'Please see https://www.apollographql.com/docs/react/basics/caching.html for our default InMemoryCache.');\n      }\n\n      if (!options.storage) {\n        throw new Error('In order to persist your Apollo Cache, you need to pass in an underlying storage provider. ' + 'Please see https://github.com/apollographql/apollo-cache-persist#storage-providers');\n      }\n\n      var log = new Log(options);\n      var cache = new Cache(options);\n      var storage = new Storage(options);\n      var persistor = new Persistor({\n        log: log,\n        cache: cache,\n        storage: storage\n      }, options);\n      var trigger = new Trigger({\n        log: log,\n        persistor: persistor\n      }, options);\n      this.log = log;\n      this.cache = cache;\n      this.storage = storage;\n      this.persistor = persistor;\n      this.trigger = trigger;\n    }\n\n    CachePersistor.prototype.persist = function () {\n      return this.persistor.persist();\n    };\n\n    CachePersistor.prototype.restore = function () {\n      return this.persistor.restore();\n    };\n\n    CachePersistor.prototype.purge = function () {\n      return this.persistor.purge();\n    };\n\n    CachePersistor.prototype.pause = function () {\n      this.trigger.pause();\n    };\n\n    CachePersistor.prototype.resume = function () {\n      this.trigger.resume();\n    };\n\n    CachePersistor.prototype.remove = function () {\n      this.trigger.remove();\n    };\n\n    CachePersistor.prototype.getLogs = function (print) {\n      if (print === void 0) {\n        print = false;\n      }\n\n      if (print) {\n        this.log.tailLogs();\n      } else {\n        return this.log.getLogs();\n      }\n    };\n\n    CachePersistor.prototype.getSize = function () {\n      return this.storage.getSize();\n    };\n\n    return CachePersistor;\n  }();\n\n  var persistCache = function persistCache(options) {\n    var persistor = new CachePersistor(options);\n    return persistor.restore();\n  };\n\n  exports.CachePersistor = CachePersistor;\n  exports.persistCache = persistCache;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":null,"metadata":{},"sourceType":"script"}